module Graphics.Animation where

{-|
  This module provides a framework for creating animations.
 -}

import Graphics.Collage as Collage

{-|
  A Location within a Form
 -}
type Location 
 = { left : Float
   , top : Float
   }
   
{-|   
  Creates a Location
 -}
loc : (Float, Float) -> Location
loc (left, top) = {left = left, top = top}   

{-|
  A Renderable contains a form to be rendered
  and a location to be rendered at.
 -}
type Renderable =
  {
    element : Form
  , location : Location
  }

{-|
  An Animation has a start and end state and a duration for
  how long it should take to transform between the two states.

  The animate operation takes in a starting time and an Renderable
  and produces a time varying renderable.

 -}
type Animation a
 = { start    : a
   , end      : a
   , duration : Time
   , animate  : Time -> Renderable -> (Time -> Renderable) 
   }

{-|
  A MoveAnimation transforms its location over time
 -}
type MoveAnimation = Animation Location

{-|
  Constructs a MoveAnimation from the first location to the
  second location at a constant speed between the locations 
  over the duration specified.
 -}
move : Location -> Location -> Time -> MoveAnimation
move start end duration = ease start end duration linear

{-|
  Constructs a MoveAnimation along a path generated by the provided locations
  at a constant speed over the entire duration.
 -}
moveMany : [Location] -> Time -> MoveAnimation
moveMany ls time = composeMany <| moveManyHelp ls time (totalDistance ls)

moveManyHelp : [Location] -> Time -> Float -> [MoveAnimation]
moveManyHelp (l0::l1::ls) time total = 
  let duration = time*((distance l0 l1)/total) in
  case ls of
    [] -> [move l0 l1 duration]
    _ -> (move l0 l1 duration) :: (moveManyHelp (l1::ls) time total)

distance : Location -> Location -> Float
distance l0 l1 = 
  let a = abs (l0.left - l1.left)
      b = abs (l0.top - l1.top)
  in sqrt <| a*a + b*b

totalDistance : [Location] -> Float
totalDistance ls = 
  let (_, val) =
        case ls of
          [] -> (loc (0,0), 0)
          (l::ls) -> foldl (\(l1, acc) l0 -> (l0, acc + (distance l0 l1))) (l, 0) ls
  in val
                       
{-|     
  An EasingFunction takes in the percentage [0,1] of time that has passed and
  returns the percentage of travel that has been completed.
 -}
type EasingFunction = Float -> Float

linear : EasingFunction
linear = id

sine : EasingFunction
sine t = (sin((t*pi)-(pi/2))+1)/2

{-|
  Constructs a MoveAnimation from the first location to the
  second location using an EasingFunction.
 -}
ease : Location -> Location -> Time -> EasingFunction -> MoveAnimation
ease start end duration easing = 
  let animateMove startTime renderable =
        let dLeft = end.left - start.left
            dTop = end.top - start.top
        in \ t -> 
             if t < startTime
                then renderable
                else
                  let percentage = easing <| max (min ((t - startTime)/duration) 1.0) 0
                      newLeft = start.left + dLeft*percentage
                      newTop = start.top + dTop*percentage
                  in {renderable| location <- loc (newLeft, newTop)}
  in
  { start = start, end = end, duration = duration, animate = animateMove }



{-|     
  Given a width, height, and list of Renderables, generates an Element with
  each Renderable within it. The first elements will be displayed beneath the
  last elements.
 -}
render : Int -> Int -> [Renderable] -> Element
render width height rs =
  let translate r = Collage.move (r.location.left, r.location.top) r.element
      moved = map translate rs
      frame = Collage.collage width height moved
  in frame

{-|
  Composes two animations.
 -}
compose : Animation a -> Animation a -> Animation a
compose ma0 ma1 =
  let start = ma0.start
      end = ma1.end
      duration = ma0.duration + ma1.duration
      animateMove startTime renderable =
        \t -> if t < startTime
                 then renderable
                 else 
                   let currentTime = t - startTime in
                   if currentTime <= ma0.duration
                     then ma0.animate startTime renderable t
                     else ma1.animate startTime renderable (t - ma0.duration)
  in 
   { start = start
   , end = end
   , duration = duration
   , animate = animateMove}

{-|
  Composes many animations together from left to right.
 -}
composeMany : [Animation a] -> Animation a
composeMany (a::anims) = foldl compose a anims
   

foldl : (a -> b -> a) -> a -> [b] -> a
foldl f z0 xs0 = 
  let lgo z zs =
        case zs of
             [] -> z
             (x::xs) -> lgo (f z x) xs
  in lgo z0 xs0
