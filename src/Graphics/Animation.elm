module Graphics.Animation where

{-|
  This module provides a framework for creating animations.
 -}

import Graphics.Collage as Collage

{-|
  A Location within a Form
 -}
type Location 
 = { left : Float
   , top : Float
   }
   
{-|   
  Creates a Location
 -}
loc : (Float, Float) -> Location
loc (left, top) = {left = left, top = top}   

{-|
  A Renderable contains a form to be rendered
  and a location to be rendered at.
 -}
type Renderable =
  {
    element : Form
  , location : Location
  }

{-|
  An Animation has a start and end state and a duration for
  how long it should take to transform between the two states.

  The animate operation takes in a starting time and an Renderable
  and produces a time varying renderable.

 -}
type Animation a
 = { start    : a
   , end      : a
   , duration : Time
   , animate  : Time -> Renderable -> (Time -> Renderable) 
   }

{-|
  A MoveAnimation transforms its location over time
 -}
type MoveAnimation = Animation Location

{-|
  Constructs a MoveAnimation from the first location to the
  second location at a constant speed between the locations 
  over the duration specified.
 -}
move : Location -> Location -> Time -> MoveAnimation
move = moveWithEase linear

{-|
  Constructs a MoveAnimation from the first location to the
  second location using the easing function to determing where
  to rednder over the duration specified
 -}
moveWithEase : EasingFunction -> Location -> Location -> Time -> MoveAnimation
moveWithEase easing start end duration = 
  let animateMove startTime renderable =
        let dLeft = end.left - start.left
            dTop = end.top - start.top
        in \ t -> 
                  let percentage = (t - startTime)/duration
                      newLeft = start.left + dLeft*percentage
                      newTop = start.top + dTop*percentage
                  in {renderable| location <- loc (newLeft, newTop)}
  in ease easing <| 
  { start = start, end = end, duration = duration, animate = animateMove }

{-|
  Constructs a MoveAnimation along a path generated by the provided locations
  at a constant speed over the entire duration.
 -}
moveMany : [Location] -> Time -> MoveAnimation
moveMany ls time = composeMany <| moveManyHelp ls time (totalDistance ls)

moveManyHelp : [Location] -> Time -> Float -> [MoveAnimation]
moveManyHelp (l0::l1::ls) time total = 
  let duration = time*((distance l0 l1)/total) in
  case ls of
    [] -> [move l0 l1 duration]
    _ -> (move l0 l1 duration) :: (moveManyHelp (l1::ls) time total)

distance : Location -> Location -> Float
distance l0 l1 = 
  let a = abs (l0.left - l1.left)
      b = abs (l0.top - l1.top)
  in sqrt <| a*a + b*b

totalDistance : [Location] -> Float
totalDistance ls = 
  let (_, val) =
        case ls of
          [] -> (loc (0,0), 0)
          (l::ls) -> foldl (\(l1, acc) l0 -> (l0, acc + (distance l0 l1))) (l, 0) ls
  in val
                       
{-|     
  An EasingFunction takes in the percentage of time that has passed (0 = 0%, 
  1 = 100%), and returns the percentage of travel that has been completed.
 -}
type EasingFunction = Float -> Float

{-|
  Given a lower and upper bound for input time, creates an easing function
  where time specified outside the range is treated as either a 0 or 1.
 -}
makeEasing : (Float, Float) -> (number -> number) -> EasingFunction
makeEasing (min, max) f t =
  if t < min then 0 else if t > max then 1 else (f t)

linear : EasingFunction
linear = makeEasing (0, 1) id

sine : EasingFunction
sine = makeEasing (0, 1) (\t -> (sin((t*pi)-(pi/2))+1)/2)

{-|
  Given an EasingFunction and an Animation, applies the EasingFunction to
  the animation. 
 -}
ease : EasingFunction -> Animation a -> Animation a
ease easing animation = 
  let animate startTime renderable t =
           let weight = easing <| (t - startTime)/animation.duration
               t' = startTime + ((animation.duration)*weight)
           in animation.animate startTime renderable t'
  in { animation | animate <- animate }


{-|     
  Given a width, height, and list of Renderables, generates an Element with
  each Renderable within it. The first elements will be displayed beneath the
  last elements.
 -}
render : Int -> Int -> [Renderable] -> Element
render width height rs =
  let translate r = Collage.move (r.location.left, r.location.top) r.element
      moved = map translate rs
      frame = Collage.collage width height moved
  in frame

{-|
  Composes two animations.
 -}
compose : Animation a -> Animation a -> Animation a
compose ma0 ma1 =
  let start = ma0.start
      end = ma1.end
      duration = ma0.duration + ma1.duration
      animateMove startTime renderable =
        \t -> let currentTime = t - startTime in
                  if currentTime <= ma0.duration
                     then ma0.animate startTime renderable t
                     else ma1.animate startTime renderable (t - ma0.duration)
  in 
   { start = start
   , end = end
   , duration = duration
   , animate = animateMove}

{-|
  Composes many animations together from left to right.
 -}
composeMany : [Animation a] -> Animation a
composeMany (a::anims) = foldl compose a anims
   

foldl : (a -> b -> a) -> a -> [b] -> a
foldl f z0 xs0 = 
  let lgo z zs =
        case zs of
             [] -> z
             (x::xs) -> lgo (f z x) xs
  in lgo z0 xs0
